<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>从输入 url 到构建完 DOM 树的优化方案(2020-12)</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black.css" id="theme">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>从输入 url 到构建完 DOM 树的优化方案</section>
        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>优化技术及标准的发展</h3>
            <img src="static/performance-2020/0.png" style="width: 100%">
        </section>
        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>资源加载</h3>
            <p>输入 url 的时候，WebKit 调用资源加载器依赖网络模块建立连接，异步或同步获取资源并存入缓存池中</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(网络协议)</h3>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(浏览器机制)</h3>
            <p> 减少链接的重定向。避免阻碍浏览器 DNS 预取技术</p>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>
                <link rel="dns-prefetch" href="http://prefetch-example.com">
            </code></pre>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(压缩算法)</h3>
            <p>针对常见的 Web 资源内容，Google 的新压缩算法 Brotli 的性能相比 Gzip 提高了 17-25%；</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(压缩算法)</h3>
            <p>针对常见的 Web 资源内容，Google 的新压缩算法 Brotli 的性能相比 Gzip 提高了 17-25%；</p>
            <img src="static/performance-2020/Brotli.png" style="width: 100%">
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(图片格式)</h3>
            <p>Netflix(流媒体影视公司) 今年情人节公布 AVIF 图片格式</p>
            <p>AVIF由开源组织AOMedia开发，Netflix、Google与Apple均是该组织的成员。</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(图片格式)</h3>
            <div style="display: flex; justify-content: space-between">
                <img width="40%" src="static/performance-2020/AVIF-before.png">
                <img width="40%" src="static/performance-2020/AVIF-after.png">
            </div>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(图片格式)</h3>
            <div style="display: flex; justify-content: space-between">
                <img width="40%" src="static/performance-2020/AVIF-before.png">
                <img width="40%" src="static/performance-2020/AVIF-after.png">
            </div>
            <div style="display: flex; justify-content: space-between">
                <div style="width: 40%;text-align: center">无损 png 700k</div>
                <div style="width: 40%;text-align: center">AVIF 20k</div>
            </div>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(图片格式)</h3>
            <p>使用 AVIF ?</p>
            <img src="static/performance-2020/AVIF.png" style="width: 100%">
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(图片格式)</h3>
            <p>使用 4kb 的 AVIF polyfill</p>
            <img src="static/performance-2020/AVIF-js.png" style="width: 100%">
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(ES modules)</h3>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>
                <script type="module">
                  import {addTextToBody} from './utils.mjs';

                  addTextToBody('Modules are pretty cool.');
                </script>
            </code></pre>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(ES modules)</h3>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>
                <script type="module">
                  import {addTextToBody} from './utils.mjs';

                  addTextToBody('Modules are pretty cool.');
                </script>
            </code></pre>
            <p> 每个支持 type="module" 的浏览器都支持你所熟知的大部分 ES2015+ 语法!!!!!</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(ES modules)</h3>
            <p> 每个支持 type="module" 的浏览器都支持你所熟知的大部分 ES2015+ 语法!!!!!</p>
            <ul>
                <li>原生支持 async 和 await 函数</li>
                <li>原生支持 class 类</li>
                <li>原生支持箭头函数</li>
                <li>原生支持 fetch 、Promises、Map、Set </li>
            </ul>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(ES modules)</h3>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>
                <script type="module" src="app.js"></script>
                <!-- 优雅降级 -->
                <script nomodule src="app-legacy.js"></script>
            </code></pre>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(ES modules)</h3>
            <img width="100%" src="static/performance-2020/module-size.png">
            <img width="100%" src="static/performance-2020/module-eval.png">
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(ES modules)</h3>
            <p> 编写 ES2015+ 代码是开发人员的胜利，部署 ES2015+ 代码则是用户的胜利！</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>构建渲染对象，渲染层</h3>
            <ul>
                <li>解释器根据 Token 构建 Node，形成 DOM 树</li>
                <li>CSS 解析完成形成 CSSOM 后，在 DOM 树上附加样式信息，构建 RenderObject 树</li>
                <li>同时，WebKit 根据网页层次结构创建 RenderLayer 树</li>
                <li>合成 RenderLayer 层，<em>递归</em>布局计算(避免不必要重绘与重排)</li>
            </ul>
        </section>

        <section  data-auto-animate data-auto-animate-unmatched="fade">
            <p>渲染优化时间(减少重绘)</p>
            <p>计算布局 -> 绘图 -> 合成</p>
        </section>

        <section  data-auto-animate data-auto-animate-unmatched="fade">
            <p>渲染优化(性能红利)</p>
            <ul>
                <li>flex Grid 布局 </li>
                <li>document.elementFromPoint(拖动时检测鼠标下的节点)</li>
                <li>虚拟滚动</li>
                <li>contain(当前修改的元素是否独立、是否影响其他元素)</li>
                <li>content-visibility(跳过不在屏幕上的内容渲染)</li>
            </ul>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <p>渲染优化(减少重绘)</p>
            <p>多 canvas 合成</p>
            <ul>
                <li>1. 背景 </li>
                <li>2. 障碍物 </li>
                <li>3. 炸弹，金钱 </li>
                <li>4. 任务</li>
            </ul>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>Google V8 引擎</h3>
            <img src="static/performance-2020/V8.png" style="width: 100%">
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>Google V8 引擎</h3>
            <img src="static/performance-2020/V8.png" style="width: 100%">
            <p>为什么 V8 早期引入 JIT ?</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>Google V8 引擎</h3>
            <img src="static/performance-2020/V8.png" style="width: 100%">
            <p>V8 创始人 Lars Bak 就是 HotSpot VM(使用范围最广的Java虚拟机) 主负责人</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>V8 引擎</h3>
            <p>解释器(Ignition) JIT 编译 字节码(同时解析字节码)</p>
            <p>编译器(Turbofan 二进制代码 | Liftoff[WebAssembly])</p>
        </section>


        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>V8 引擎优化(隐藏类)</h3>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>
                <script type="module">
                    function add(a,b) {
                      return a.x * b.y
                    }
                </script>
            </code></pre>
            没办法知道类型???
        </section>


        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>V8 引擎优化(隐藏类)</h3>
            <p>C++ 对象(静态语言)</p>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>
                   class Class1 {
                     int x;
                     int y;
                   }

                   int add (Class1 a, Class1 b) {
                     return a.x * b.y
                   }
            </code></pre>

        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>V8 引擎优化(隐藏类)</h3>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>
                   class Class1 {
                     int x;
                     int y;
                   }

                   int add (Class1 a, Class1 b) {
                     return a.x * b.y
                   }
            </code></pre>
            <p>地址与类型， x: 基地址 y: 基地址 + 4 (平台确定)</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>V8 引擎优化(隐藏类)</h3>
            <p>静态语言 / 动态语言</p>
            <ul>
                <li>编译确定偏移位置 / 执行确定偏移位置(可修改)</li>
                <li>偏移信息共享 / 自描述，存在自身结构(空间消耗)</li>
                <li>偏移信息查找 / 属性名称匹配查找(时间消耗)</li>
            </ul>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>V8 引擎优化(隐藏类)</h3>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>

                function Class1(x,y) {
                    this.x = x;
                    this.y = y;
                }

                var a = new Class1(1,1)
                var b = new Class1(2,2)
            </code></pre>
            <p>隐藏类  x: 基地址 y: 基地址 + 4</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>V8 引擎优化(隐藏类)</h3>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>

                function Class1(x,y) {
                    this.x = x;
                    this.y = y;
                }

                var a = new Class1(1,1)
                var b = new Class1(2,2)
                b.z = 2

            </code></pre>
            <p>2 个隐藏类</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>V8 引擎优化(隐藏类)</h3>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>

                function Class1(x,y) {
                    this.x = x;
                    this.y = y;
                }

                var a = new Class1(1,1)
                var b = new Class1(2,2)
                b.z = 2

            </code></pre>
            <p>delete 也会破坏隐藏类吗？</p>

        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>V8 引擎优化(隐藏类)</h3>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>

                function Class1(x,y) {
                    this.x = x;
                    this.y = y;
                }

                var a = new Class1(1,1)
                var b = new Class1(2,2)
                b.z = 2

            </code></pre>
            <p>如何将 delete 操作影响最小?</p>
        </section>


        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>V8 引擎优化(优化回滚)</h3>
            <pre data-id="code"><code data-line-numbers="3-6|3-6|3-6|3-6|7-8" class="hljs" data-trim>
                var count = 0;
                function test() {
                    count++
                    if (count < 1000000) {
                        return 123
                    }
                    var unknown = new Date()
                    return unknown
                }
            </code></pre>
            <p>如何将 delete 操作影响最小?</p>
        </section>






        <section>优化回滚</section>
        <section>gpu 流水线</section>

        <section>V8 跳过预渲染</section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>其他优化(批处理机制)</h3>
        </section>

        <section>workerDom</section>
        <section>WASM 与 Webwork</section>

        <section>
            不管当前硬件多强大，一台计算机的能力总是有限的，而你也无法预知你正在开发的应用将来会变得多庞大，也不会知道什么时间会出现性能瓶颈。
            性能的问题是一个习惯的问题，我们平时如果看到了更优的解法，认可这种解法，就应该改变自己原有的习惯，然后把应用这种更优解法变成你的习惯。
            性能的事情也是点滴的事情，你的页面不会因为多了1万次循环变得卡顿，也不会因为你减少了1万次循环变得异常流畅。但是一旦你的页面出现了卡顿，想再回头优化到流畅通常是很难的。
            先做功能，回头再优化性能是不对的，性能的事情要在写代码前就已经解决的。

        </section>
    </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
  // More info about initialization & config:
  // - https://revealjs.com/initialization/
  // - https://revealjs.com/config/
  Reveal.initialize({
    hash: true,
    center: true,
    // Learn about plugins: https://revealjs.com/plugins/
    plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
  });
</script>
</body>
</html>
