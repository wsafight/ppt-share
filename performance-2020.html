<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>从输入 url 到生成网页的优化方案(2020-12)</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black.css" id="theme">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>从输入 url 到生成网页的优化方案</section>
        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>优化技术及标准的发展</h3>
            <img src="static/performance-2020/0.png" style="width: 100%">
        </section>
        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>资源加载</h3>
            <p>输入 url 的时候，WebKit 调用资源加载器依赖网络模块建立连接，异步或同步获取资源并存入缓存池中</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(网络协议的升级)</h3>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(浏览器机制)</h3>
            <p> 减少链接的重定向。避免阻碍浏览器 DNS 预取技术</p>

        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(浏览器机制)</h3>
            <p> 减少链接的重定向。避免阻碍浏览器 DNS 预取技术</p>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>
                <link rel="dns-prefetch" href="http://prefetch-example.com">
            </code></pre>
        </section>


        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(压缩算法)</h3>
            <p>针对常见的 Web 资源内容，Google 的新压缩算法 Brotli 的性能相比 Gzip 提高了 17-25%；</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(压缩算法)</h3>
            <p>针对常见的 Web 资源内容，Google 的新压缩算法 Brotli 的性能相比 Gzip 提高了 17-25%；</p>
            <img src="static/performance-2020/Brotli.png" style="width: 100%">
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(图片格式)</h3>
            <p>Netflix(流媒体影视公司) 今年情人节公布 AVIF 图片格式</p>
            <p>AVIF由开源组织AOMedia开发，Netflix、Google与Apple均是该组织的成员。</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(图片格式)</h3>
            <div style="display: flex; justify-content: space-between">
                <img width="40%" src="static/performance-2020/AVIF-before.png">
                <img width="40%" src="static/performance-2020/AVIF-after.png">
            </div>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(图片格式)</h3>
            <div style="display: flex; justify-content: space-between">
                <img width="40%" src="static/performance-2020/AVIF-before.png">
                <img width="40%" src="static/performance-2020/AVIF-after.png">
            </div>
            <div style="display: flex; justify-content: space-between">
                <div style="width: 40%;text-align: center">无损 png 700k</div>
                <div style="width: 40%;text-align: center">AVIF 20k</div>
            </div>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(图片格式)</h3>
            <p>使用 AVIF ?</p>
            <img src="static/performance-2020/AVIF.png" style="width: 100%">
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(图片格式)</h3>
            <p>使用 4kb 的 AVIF polyfill</p>
            <img src="static/performance-2020/AVIF-js.png" style="width: 100%">
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(ES modules)</h3>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>
                <script type="module">
                  import {addTextToBody} from './utils.mjs';

                  addTextToBody('Modules are pretty cool.');
                </script>
            </code></pre>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(ES modules)</h3>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>
                <script type="module">
                  import {addTextToBody} from './utils.mjs';

                  addTextToBody('Modules are pretty cool.');
                </script>
            </code></pre>
            <p> 每个支持 type="module" 的浏览器都支持你所熟知的大部分 ES2015+ 语法!!!!!</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(ES modules)</h3>
            <p> 每个支持 type="module" 的浏览器都支持你所熟知的大部分 ES2015+ 语法!!!!!</p>
            <ul>
                <li>原生支持 async 和 await 函数</li>
                <li>原生支持 class 类</li>
                <li>原生支持箭头函数</li>
                <li>原生支持 fetch 、Promises、Map、Set</li>
            </ul>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(ES modules)</h3>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>
                <script type="module" src="app.js"></script>
                <!-- 优雅降级 -->
                <script nomodule src="app-legacy.js"></script>
            </code></pre>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(ES modules)</h3>
            <img width="100%" src="static/performance-2020/module-size.png">
            <img width="100%" src="static/performance-2020/module-eval.png">
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(ES modules)</h3>
            <p> 编写 ES2015+ 代码是开发人员的胜利</p>
            <p> 部署 ES2015+ 代码则是用户的胜利</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>构建渲染对象，渲染层</h3>
            <ul>
                <li>解释器根据 Token 构建 Node，形成 DOM 树</li>
                <li>CSS 解析完成形成 CSSOM 后，在 DOM 树上附加样式信息，构建 RenderObject 树</li>
                <li>同时，WebKit 根据网页层次结构创建 RenderLayer 树</li>
                <li>合成 RenderLayer 层，<em>递归</em>布局计算(避免不必要重绘与重排)</li>
            </ul>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <p>渲染优化时间(减少重绘)</p>
            <p>计算布局 -> 绘图 -> 合成</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <p>渲染优化(性能红利)</p>
            <ul>
                <li>flex Grid 布局</li>
                <li>document.elementFromPoint(拖动时检测鼠标下的节点)</li>
                <li>虚拟滚动</li>
                <li>contain(当前修改的元素是否独立、是否影响其他元素)</li>
                <li>content-visibility(跳过不在屏幕上的内容渲染)</li>
            </ul>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <p>渲染优化(减少重绘)</p>
            <p>多 canvas 合成</p>
            <ul>
                <li>1. 背景</li>
                <li>2. 障碍物</li>
                <li>3. 炸弹，金钱</li>
                <li>4. 任务</li>
            </ul>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>Google V8 引擎</h3>
            <img src="static/performance-2020/V8.png" style="width: 100%">
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>Google V8 引擎</h3>
            <img src="static/performance-2020/V8.png" style="width: 100%">
            <p>为什么 V8 早期引入 JIT ?</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>Google V8 引擎</h3>
            <img src="static/performance-2020/V8.png" style="width: 100%">
            <p>V8 创始人 Lars Bak 就是 HotSpot VM(使用范围最广的Java虚拟机) 主负责人</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>V8 引擎</h3>
            <p>解释器(Ignition) JIT 编译 字节码(同时解析字节码)</p>
            <p>编译器(Turbofan 二进制代码 | Liftoff[WebAssembly])</p>
        </section>


        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>V8 引擎优化(隐藏类)</h3>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>
                <script type="module">
                    function add(a, b) {
                      return a.x * b.y
                    }
                </script>
            </code></pre>
            没办法知道类型???
        </section>


        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>V8 引擎优化(隐藏类)</h3>
            <p>C++ 对象(静态语言)</p>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>
                   class Class1 {
                     int x;
                     int y;
                   }

                   int add (Class1 a, Class1 b) {
                     return a.x * b.y
                   }
            </code></pre>

        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>V8 引擎优化(隐藏类)</h3>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>
                   class Class1 {
                     int x;
                     int y;
                   }

                   int add (Class1 a, Class1 b) {
                     return a.x * b.y
                   }
            </code></pre>
            <p>地址与类型， x: 基地址 y: 基地址 + 4 (平台确定)</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>V8 引擎优化(隐藏类)</h3>
            <p>静态语言 / 动态语言</p>
            <ul>
                <li>编译确定偏移位置 / 执行确定偏移位置(可修改)</li>
                <li>偏移信息共享 / 自描述，存在自身结构(空间消耗)</li>
                <li>偏移信息查找 / 属性名称匹配查找(时间消耗)</li>
            </ul>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>V8 引擎优化(隐藏类)</h3>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>

                function Class1(x,y) {
                    this.x = x;
                    this.y = y;
                }

                var a = new Class1(1,1)
                var b = new Class1(2,2)
            </code></pre>
            <p>隐藏类 x: 基地址 y: 基地址 + 4</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>V8 引擎优化(隐藏类)</h3>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>

                function Class1(x,y) {
                    this.x = x;
                    this.y = y;
                }

                var a = new Class1(1,1)
                var b = new Class1(2,2)
                b.z = 2

            </code></pre>
            <p>2 个隐藏类</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>V8 引擎优化(隐藏类)</h3>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>

                function Class1(x,y) {
                    this.x = x;
                    this.y = y;
                }

                var a = new Class1(1,1)
                var b = new Class1(2,2)
                b.z = 2

            </code></pre>
            <p>delete 也会破坏隐藏类吗？</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>V8 引擎优化(隐藏类)</h3>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>

                function Class1(x,y) {
                    this.x = x;
                    this.y = y;
                }

                var a = new Class1(1,1)
                var b = new Class1(2,2)
                b.z = 2

            </code></pre>
            <p>如何将 delete 操作影响最小?</p>
        </section>


        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>V8 引擎优化(优化回滚)</h3>
            <pre data-id="code"><code data-line-numbers="3|4|5|6|3|4|5|6|7-8" class="hljs" data-trim>
                var count = 0;
                function test() {
                    count++
                    if (count < 1000000) {
                        return 123
                    }
                    var unknown = new Date()
                    return unknown
                }
            </code></pre>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>其他优化(批处理机制)</h3>
            <p>在可接受的时间内，将多次调用合成一次调用</p>
            <ul>
                <li>Vue React 异步设值</li>
                <li>requestAnimationFrame 操作 dom(fastdom)</li>
                <li>大量而不实时计算数据修改</li>
            </ul>
        </section>


        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>其他优化(多线程)</h3>
            <p>web-worker 优劣</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>其他优化(多线程)</h3>
            <p>web-worker 优劣</p>
            <p>pwa workerDom 渲染</p>
        </section>


        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>其他优化(多线程)</h3>
            <p>web-worker 优劣</p>
            <p>pwa workerDom 渲染</p>
            <p>neo.mjs 多线程框架</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>其他优化(WASM 演进)</h3>
            <p>解决 js 动态问题(asm.js)</p>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>
                var a = 1;
                var x = a | 0;  // x 是32位整数
                var y = +a;  // y 是64位浮点数
            </code></pre>
        </section>


        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>其他优化(WASM 演进)</h3>
            <p>解决 js 动态问题(WebAssembly)</p>
            <p>java => .class</p>
            <p>webAssembly => .wasm</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>其他优化(WASM 演进)</h3>
            <p>解决 js 动态问题(WebAssembly)</p>
            <p>C / C ++, Java, GO, C#, D, Haxe, TypeScript(AssemblyScript)...</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>其他优化(WASM 演进)</h3>
            <p> 标准化中的 WASI：在 web 之外运行 WebAssembly 的系统接口</p>
            <p> WebAssembly 是概念机的汇编语言，而不是物理机的汇编语言。 这就是它可以在各种不同计算机体系结构上运行的原因。</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <p>......</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <p>......</p>
            <p>业务层面优化</p>

        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <p>......</p>
            <p>业务层面优化</p>
            <p>没有银弹</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <ul>
                <li>不管当前硬件多强大，一台计算机的能力总是有限的，复杂系统开发，我们无法预料合适会出现性能瓶瓶颈</li>
                <li>性能的问题是一个习惯的问题，看到了更优的解法后，应用这种更优解法变成你的习惯</li>
                <li>性能的事情也是点滴的事情， 页面不会因为多了1万次循环变得卡顿，也不会因为减少了1万次循环变得异常流畅</li>
            </ul>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            谢谢观看
        </section>
    </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
  // More info about initialization & config:
  // - https://revealjs.com/initialization/
  // - https://revealjs.com/config/
  Reveal.initialize({
    hash: true,
    center: true,
    // Learn about plugins: https://revealjs.com/plugins/
    plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
  });
</script>
</body>
</html>
