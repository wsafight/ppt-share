<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>从输入 url 到构建完 DOM 树的优化方案(2020-12)</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black.css" id="theme">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>从输入 url 到构建完 DOM 树的优化方案</section>
        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>优化技术及标准的发展</h3>
            <img src="static/performance-2020/0.png" style="width: 100%">
        </section>
        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>资源加载</h3>
            <p>输入 url 的时候，WebKit 调用资源加载器依赖网络模块建立连接，异步或同步获取资源并存入缓存池中</p>
        </section>


        <section></section>
        <section>图片格式</section>
        <section>type='module'</section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略</h3>
            <p>网络协议的升级</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(浏览器机制)</h3>
            <p> 减少链接的重定向。避免阻碍浏览器 DNS 预取技术</p>
            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>
                <link rel="dns-prefetch" href="http://prefetch-example.com">
            </code></pre>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(网络协议)</h3>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策(压缩算法)</h3>
            <p>针对常见的 Web 资源内容，Google Brotli 的性能相比 Gzip 提高了 17-25%；</p>
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(压缩算法)</h3>
            <p>针对常见的 Web 资源内容，Google 的新压缩算法 Brotli 的性能相比 Gzip 提高了 17-25%；</p>
            <img src="static/performance-2020/Brotli.png" style="width: 100%">
        </section>

        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>高效的资源加载策略(图片格式)</h3>
            <p>Netflix(流媒体影视公司) 今年情人节公布 AVIF 图片格式</p>
            <p>AVIF由开源组织AOMedia开发，Netflix、Google与Apple均是该组织的成员。</p>
            <img src="static/performance-2020/Brotli.png" style="width: 100%">
        </section>


        <section data-auto-animate data-auto-animate-unmatched="fade">
            <h3>资源加载</h3>
            <p>dns 预取与 TCP 预连接</p>
            <p>dns 预取技术利用较少的 CPU 和 带宽解析域名以及 IP 地址</p>

            <pre data-id="code"><code data-line-numbers class="hljs" data-trim>
						function Example() {
						  const [count, setCount] = useState(0);
						}
					</code></pre>

        </section>


        <section>
            <h3>解析</h3>
            <p>解释器根据 Token 构建 Node，形成 DOM 树</p>
        </section>

        <section>DOM批处理 思考?</section>
        <section>网页层次 </section>

        <section>
            <h3>解析</h3>
            <p>Css 解析完成后，在 DOM 树上附加样式信息，构建 RenderObject 树</p>
            <p>同时，WebKit 根据网页层次结构创建 RenderLayer 树</p>

        </section>
        <section>css 优化 gpu</section>
        <section>性能红利 flex grid</section>
        <section>可视区优化</section>

        <section>
            <p>javaScript 引擎执行</p>
        </section>

        <section>JS 优化</section>
        <section>隐藏类</section>
        <section>优化回滚</section>
        <section>gpu 流水线</section>

        <section>V8 跳过预渲染</section>


        <section>未来</section>
        <section>workerDom</section>
        <section>WASM 与 Webwork</section>

        <section>
            不管当前硬件多强大，一台计算机的能力总是有限的，而你也无法预知你正在开发的应用将来会变得多庞大，也不会知道什么时间会出现性能瓶颈。
            性能的问题是一个习惯的问题，我们平时如果看到了更优的解法，认可这种解法，就应该改变自己原有的习惯，然后把应用这种更优解法变成你的习惯。
            性能的事情也是点滴的事情，你的页面不会因为多了1万次循环变得卡顿，也不会因为你减少了1万次循环变得异常流畅。但是一旦你的页面出现了卡顿，想再回头优化到流畅通常是很难的。
            先做功能，回头再优化性能是不对的，性能的事情要在写代码前就已经解决的。

        </section>
    </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
  // More info about initialization & config:
  // - https://revealjs.com/initialization/
  // - https://revealjs.com/config/
  Reveal.initialize({
    hash: true,
    center: true,
    // Learn about plugins: https://revealjs.com/plugins/
    plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
  });
</script>
</body>
</html>
